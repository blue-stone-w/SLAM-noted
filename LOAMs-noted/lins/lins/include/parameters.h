/*
Description: done
*/
#ifndef INCLUDE_PARAMETERS_H_
#define INCLUDE_PARAMETERS_H_

#include <math.h>
#include <nav_msgs/Odometry.h>
#include <pcl/common/common.h>
#include <pcl/filters/filter.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl/kdtree/kdtree_flann.h>
#include <pcl/point_cloud.h>
#include <pcl/point_types.h>
#include <pcl/range_image/range_image.h>
#include <pcl/registration/icp.h>
#include <pcl_conversions/pcl_conversions.h>
#include <pcl_ros/point_cloud.h>
#include <ros/ros.h>
#include <sensor_msgs/Imu.h>
#include <sensor_msgs/NavSatFix.h>
#include <sensor_msgs/PointCloud2.h>
#include <tf/transform_broadcaster.h>
#include <tf/transform_datatypes.h>
#include <tic_toc.h>

#include <eigen3/Eigen/Dense>
#include <fstream>
#include <iostream>
#include <mutex>
#include <opencv2/core/eigen.hpp>
#include <opencv2/opencv.hpp>
#include <queue>
#include <thread>

#include "cloud_msgs/cloud_info.h" // this header file is generated by compiling

typedef pcl::PointXYZI PointType;

typedef Eigen::Vector3d V3D;
typedef Eigen::Matrix3d M3D;
typedef Eigen::VectorXd VXD;
typedef Eigen::MatrixXd MXD;
typedef Eigen::Quaterniond Q4D;

namespace parameter
{

// earth coefficients
const double G0     = 9.81; // local gravity
const double deg    = M_PI / 180.0; // degree, for transformation from deg to rad
const double rad    = 180.0 / M_PI; // radian
const double dph    = deg / 3600.0; // degree per hour
const double dpsh   = deg / sqrt(3600.0); // degree per square-root hour
const double mg     = G0 / 1000.0; // milli-gravity force; a non-standard gravitational metric unit of force
const double ug     = mg / 1000.0; // micro-gravity force(Microgravity is the condition in which people or objects appear to be weightless)
const double mgpsHz = mg / sqrt(1.0); // milli-gravity force per second
const double ugpsHz = ug / sqrt(1.0); // micro-gravity force per second
const double Re     = 6378137.0; // < WGS84 Equatorial radius in meters; 赤道半径
const double Rp     = 6356752.31425; // 极半径
const double Ef     = 1.0 / 298.257223563; // 扁率
const double Wie    = 7.2921151467e-5; // 地球自转角速度，弧度/秒
const double Ee     = 0.0818191908425; // 地球第一偏心率
const double EeEe   = Ee * Ee; //

// SLAM coefficients
const bool loopClosureEnableFlag    = true;
const double mappingProcessInterval = 0.3;
const float ang_res_x               = 0.2; // angle resolution in deg
const float ang_res_y               = 2.0;
const float ang_bottom              = 15.0 + 0.1; // used for computing rowIdn
const int groundScanInd             = 5; // num of lowest lines for extracting ground points
const int systemDelay               = 0;
const float sensorMountAngle        = 0.0; // angle between horizonal plane and XOY plane in lidar frame
const float segmentTheta            = 1.0472; // to judge whether two points are neighbors
const int segmentValidPointNum      = 5; // num of points in a valid segment must be higher than this value
const int segmentValidLineNum       = 3;
const float segmentAlphaX           = ang_res_x / 180.0 * M_PI; // angle resolution in rad
const float segmentAlphaY           = ang_res_y / 180.0 * M_PI;
const int edgeFeatureNum            = 2; // extract this num features from single section
const int surfFeatureNum            = 4;
const int sectionsTotal             = 6; // range image is divide to this num sections

const float surroundingKeyframeSearchRadius    = 50.0; // distancce for detecting loop
const int surroundingKeyframeSearchNum         = 50; // extract key frame at least this num
const float historyKeyframeSearchRadius        = 5.0; // look for loop frame in this radius
const int historyKeyframeSearchNum             = 25; // look for history key frame of loop(prev frame) in this num
const float historyKeyframeFitnessScore        = 0.3; // threshold to judge whether loop ICP result is acceptable
const float globalMapVisualizationSearchRadius = 500.0; // look for frame in this radius around robot to rviz visualize

// enable calibration
extern int CALIBRATE_IMU;
extern int SHOW_CONFIGURATION; // unused
extern int AVERAGE_NUMS; // 用于定期重新估计IMU的bias

// initial parameters
extern double IMU_LIDAR_EXTRINSIC_ANGLE;
extern double IMU_MISALIGN_ANGLE;

// lidar parameters
extern int LINE_NUM; // when we get range image, line is row(hang) num and scan is column(lie) num.
extern int SCAN_NUM;
extern double SCAN_PERIOD;
extern double EDGE_THRESHOLD;
extern double SURF_THRESHOLD;
extern double NEAREST_FEATURE_SEARCH_SQ_DIST; // 寻找最近点时，只有在这个距离范围内的最近点才有效

// test
extern int VERBOSE;
extern int ICP_FREQ; // 在迭代匹配过程中，如果每次迭代都重新寻找最近的平面和直线，计算量太大。迭代次数为这个变量的整数倍时才寻找最近的特征
extern int MAX_LIDAR_NUMS; // 没有使用
extern int NUM_ITER; // 迭代匹配时的最大迭代次数
extern double LIDAR_SCALE; // 在迭代匹配过程中的匹配残差*该变量=最终的残差
extern double LIDAR_STD; // 雷达点云匹配的噪声

// sub topic name
extern std::string IMU_TOPIC;
extern std::string LIDAR_TOPIC;

// pub topic name
extern std::string LIDAR_ODOMETRY_TOPIC;
extern std::string LIDAR_MAPPING_TOPIC;

// kalman filter
extern double ACC_N; // accelerate noise
extern double ACC_W;
extern double GYR_N; // gyroscope noise(angluar velocity noise)
extern double GYR_W;
extern V3D INIT_POS_STD;
extern V3D INIT_VEL_STD;
extern V3D INIT_ATT_STD;
extern V3D INIT_ACC_STD;
extern V3D INIT_GYR_STD;

// initial IMU biases
extern V3D INIT_BA;
extern V3D INIT_BW;

// extrinsic parameters
extern V3D INIT_TBL; // translation
extern Q4D INIT_RBL; // rotation

// 下面是对全局函数的声明, .cpp文件中对函数进行定义, 这里的声明可以被include使用
// 同时, .cpp文件中读取变量保存在了.cpp文件的变量中, 因此，需要有一个头文件来声明extern，从而使得这个.cpp文件中的变量可以被外部使用(同一个executable)
void readParameters(ros::NodeHandle &n);

void readV3D(cv::FileStorage *file, const std::string &name, V3D &vec_eigen);

void readQ4D(cv::FileStorage *file, const std::string &name, Q4D &quat_eigen);

enum StateOrder
{ // use in stateEstimator.h, position of assignment in jacobian matrix
  O_R = 0, // R: rotation
  O_P = 3, // P: position
};

} // namespace parameter

#endif // INCLUDE_PARAMETERS_H_